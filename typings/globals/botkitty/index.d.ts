// Generated by typings
// Source: ../../../build-boteditor-Desktop_Qt_5_7_0_MSVC2015_64bit/botkitty.d.ts
declare module FileSystem {
    /**
     * @description
     * Get files and directories using a relative path which this interface represents.
     * To get your hands on one of these classes check out the fileSystem global or use Process.file.
     * All changes to the filesystem are temporary and will be cleaned up when
     * the file object is not used anymore or bot stops.
     * @example
     * ```javascript
     * 
     * //Get file and replace it with another one
     * //Use global variable fileSystem
     * var file = FileSystem.root.file("C:/programs(x86)/target_program/foo.exe");
     * //Above throws if file does not exist
     * file.replace("botrunner/relative/path.exe");	//The path from where the botrunner resides
     * //Above throws if file does not exist
     * ```
     * 
     * @example
     * ```javascript
     * 
     * //Get directory C:/sub/sub/sub
     * var dir = FileSystem.root.dir("C:/sub");
     * var dir2 = dir("sub/sub");    //Useful if you do not know the directory in advance
     * log.notify("Dir C:/sub/sub/sub found");    //Log to logging window
     * 
     * //You might wanna do something like this when you got many files to work with
     * ```
     */
    interface Dir {
        /**
         * The path which this FileSystem object represents.
         */
        readonly pathOf: string;

        /**
         * @description
         * Get a file which is sure to exist which has a relative path to the current FileSystem object.
         * Use this to replace files or just to read them as text.
         * Replaced files will be restored on bot exit.
         * @throws If file does not exist
         */
        file(relative_path: string): FileEntry;

        /**
         * @description
         * Get a directory which is sure to which has a relative path to the current FileSystem.
         * Use this to use a different relative path than the FileSystem object you are currently using.
         * @throws If file does not exist
         * @returns Dir
         */
        dir(relative_path: string): Dir;
    }

    /**
     * @description
     * Represents a single file which can be replaced by another file or read from.
     * If this file is replaced with another the contents of this file will be
     * reverted when this object is not reachable anymore or the bot session stops.
     * 
     * @example
     * ```javascript
     * 
     * //Replace game file with own modified version
     * var pid = Processes.selectedPid;
     * log.normal("Pid: ", pid);
     *
     * var process = Processes.open(pid); //Throws if failure
     *
     * var foo_file = process.file("foo.txt"); //Throws if file does not exist
     *
     * foo_file.replace("foo_replacement.txt"))   //foo_replacement.txt path is relative to botrunner directory
     *    throw "Could not replace file";
     * //As with most calls, above throws
     * ```
     */
    interface FileEntry {

        /**
         * @description
         * The path of the file representing this file entry.
         */
        readonly pathOf: string;

        /**
         * @description
         * Read the text of the file.
         * It tries to do UTF detection. Otherwise it defaults
         * to UTF-8.
         * @throws if file does not exist or does not have permissions to read it
         */
        readText(): string;

        /**
         * @description
         * Replace this file with another file which path is relative to the botrunner path.
         * 
         * @throws If botrunner file does not eixst, does not have permissions to read it or
         * can not write to the file this FileEntry represents.
         * 
         * @example
         * ```javascript
         * 
         * var file_entry = ...; //Lets so we got the file entry a Process instance
         * var replacement_file = "foo_replacement.txt";
         * 
         * file_entry.replace(replacement_file);    
         * //If BotRunner is located at
         * //C:/foo_plugin/plugin.botrunner
         * //replacement_file path becomes C:/foo_plugin/foo_replacement.txt
         * ```
         */
        replace(botrunner_relative_path: string): void;

        /**
         * @description
         * Restores the files content to what it had before this bot started.
         * Or to be more precise. Before the first reference to the actual 
         * file on the system.
         */
        restore(): void;
    }

    /**
     * @description
     * The global variable representing the root of the fileSystem
     */
    var fileSystem: Dir;

}



//Settings

/**
 * @description
 * Contains all settings which you have registered
 * in the BotRunner file as settings_declarations.
 * Storing them as an object where each key 
 * contains the value.
 * 
 * @example
 * Width the following botrunner file:
 * ```json
 * 
 * ...
 * "settings_declaration": {
 *      "foo": {
 *          "type": "combobox",
 *          "accepted": [ "zebra", "polygon" ],
 *          "default": "zebra"
 *      },
 *      "foo2": {
 *          "type": "text",
 *          "default": "smash hero"
 *      }
 * }
 * ...
 * ```
 * 
 * This settings object will contain keys "foo" and "foo2".
 */
declare const Settings: { [key: string]: string };










//HTTP

/**
 * @description
 * Make HTTP requests and automaticly keep session. This way 
 * user sessions are no problem which makes things like changing your gmail account
 * easy.
 * 
 * @example
 * ```javascript
 * 
 * var request = HTTP.get({url: "https://www.youtube.com"});    //Global http interface
 * //Throws if not successful
 *
 * var html = request.html();   //Parse as html
 * //Throws if not successful
 * 
 * var children = html.childElements;   //Iterate the top elements
 * for(var i = 0; i < children.length; ++i)
 *     Log.normal(children[i].tag);
 * // -> Normally prints head and body
 * ```
 */
declare module HTTP {

    /**
     * @description
     * Represents all configuration you can make to an request.
     * This includes headers, variables, and cookies.
     * Notice that headers override set variables and cookies.
     */
    class NetworkParam {

        /**
         * @description
         * The url. It is recommended to provide the transfer protocol (http:// or https://)
         * to get better speed and in some cases better correctness.
         */
        url: string;

        /**
         * @description
         * String of string map of headers, in raw form. Notice this can override both variables and cookies.
         */
        variables: { [key: string]: string };

        /**
         * @description
         * String of string map of cookies.
         */
        cookies: { [key: string]: string };

        /**
         * @description
         * String of string map of headers, in raw form. Notice this can override both variables and cookies.
         */
        headers: { [key: string]: string };
    }

    /**
     * @description
     * A reply from a network request.
     * Using this you can see if the request was successful
     * and parse it as either html, json or xml.
     * 
     * @example
     * ```javascript
     * 
     * var request = HTTP.get({url: "https://www.youtube.com"});
     * //Throws if request fails
     *
     * var html = request.html();   //Parse as html
     * //Throws if request can not be parsed as html
     * 
     * var children = html.childElements;   //Iterate the top elements
     * for(var i = 0; i < children.length; ++i)
     *     log.normal(children[i].tag);
     * // -> Normally prints head and body
     * ```
     */
    interface NetworkReply {

        /**
         * @description
         * url The url of the request
         */
        readonly url: string;

        /**
         * @description
         * Parses the request as JSON.
         * @throws If the request is not valid JSON.
         * @returns
         * Because JSON is a perfect match to javascript objects an object or array is returned representing the JSON.
         */
        json(): Object;

        /**
         * @description
         * Parses the request as XML
         * @throws If request is not valid XML
         * @returns The top DOM element/document representing the XML.
         */
        xml(): DomElement;

        /**
         * @description
         * Parses the request as HTML. Notice that the request data is first tidyed up to fit XML standards.
         * This might in some cases change how you would iterate the element tree.
         * @throws If request is not somewhat valid HTML.
         * @returns The document, from which child data can be queried
         */
        html(): DomElement;
    }

    /**
     * @description
     * Represents a single XML or HTML node in a tree including the top HTML document.
     */
    interface DomElement {

        /**
         * @description
         * The parent of the element
         * 
         * @returns Undefined | null if element does not have any parent
         */
        readonly parent: DomElement | null;

        /**
         * @description
         * The tagname of the element, this is empty on the top element
         */
        readonly tag: string;

        /**
         * @description
         * The free text inside of the element.
         */
        readonly text: string;

        /**
         * @description
         * The attributes of the element. Duplicates are removed
         */
        readonly attributes: { [key: string]: string };

        /**
         * @description
         * The child elements of this element.
         */
        readonly childElements: DomElement[];

        /**
         * @description
         * Select an list of elements using CSS selection syntax.
         * Normal CSS selection is supported except for some attributes which is intended to be used to
         * detect using actions.
         * So the following operators are not supported:
         * ::after
         * ::before
         * :active
         * :checked
         * :enabled
         * :disabled
         * :focus
         * :hover
         * :in-range
         * :invalid
         * :link
         * :required
         * selection
         * :target
         * :valid
         * :visited
         * ::first-letter
         * ::first-line
         * 
         * @throws If there was an syntax error
         * 
         * @returns An array of all elements found.
         * 
         * @example
         * ```javascript
         * 
         * //Select the names of all front page videos on youtube
         * var request = HTTP.get({url: "https://www.youtube.com"});
         * var html = request.html();
         * var name_nodes = html.selectElements("a[href^=/watch?v]");
         * //Select all a elements which has an attribute which starts with /watch?v
         * var names = "";
         * for(i = 0; i < name_nodes.length; ++i)
         *     names += "\n" + name_nodes[i].text;
         * print(names);
         * ```
         */
        selectElements(selection: string): DomElement[];
    }

    /**
     * @description
     * Make a HTTP get request
     */
    function get(param: NetworkParam): NetworkReply;

    /**
     * @description
     * Make a HTTP post request
     */
    function post(param: NetworkParam): NetworkReply;
}


//Logging

/**
 * @description
 * For logging messages to show the user.
 * If you just want to log and terminate do not use logging but throw
 * an string instead. Exceptions are automaticly logged.
 * 
 * @notify
 * That global function print is just an alias for Log.normal
 * 
 * @example
 * ```javascript
 * 
 * Log.error("Something failed.");  //DONT do this if you want to stop the bot because of an error
 * 
 * throw "Something failed.";   //Do this instead. It automaticly logs and stops the bot.
 * ```
 * 
 * @example
 * ```javascript
 * 
 * Log.notify("Just normal logging. It is like ", 42, ". No problem");
 * // -> "Just normal logging. It is like 42. No problem"
 * ```
 */
declare module Log {
    function notify(...args: any[]);
    function normal(...args: any[]);
    function warning(...args: any[]);
    function error(...args: any[]);
}


//GUI

/**
 * @description
 * Used to describe an additional click when using Keybutton enum to push non text or text buttons.
 */
enum Keyboard {
    Alt,
    Shift,
    Ctrl,
}

/**
 * @description
 * Used to describe what mouse button to press.
 */
enum Mouse {
    Lbutton,
    Rbutton,
    Mbutton,
    Xbutton1,
    Xbutton2,
}

/**
 * @description
 * Used to describe what special button to push which is not normally represented by
 * text such as insert or scroll lock.
 */
enum Keybutton {
    Back,
    Tab,
    Clear,
    Return_,
    Pause,
    Capslock,
    Escape,
    Convert,
    Nonconvert,
    Accept,
    Space,
    Pageup,
    Pagedown,
    End,
    Home,
    Left,
    Up,
    Right,
    Down,
    Select,
    Print,
    Execute,
    Snapshot,
    Insert,
    Delete_,
    Help,
    Lwin,
    Rwin,
    Sleep,
    Multiply,
    Add,
    Separator,
    Subtract,
    Decimal,
    Divide,
    F1,
    F2,
    F3,
    F4,
    F5,
    F7,
    F8,
    F9,
    F10,
    F11,
    F12,
    F13,
    F14,
    F15,
    F16,
    F17,
    F18,
    F19,
    F20,
    F21,
    F22,
    F23,
    F24,
    Numlock,
    Scroll,
    Lmenu,
    Rmenu,
}

/**
 * @description
 * An enum of the virtual keys as defined by Microsoft.
 * Used to define ranges which keys will be listened to.
 */
enum VirtualKey {
    LBUTTON,
    RBUTTON,
    CANCEL,
    MBUTTON,
    XbUTTON1,
    XbUTTON2,
    BACK,
    TAB,
    CLEAR,
    RETURN,
    SHIFT,
    CONTROL,
    MENU,
    PAUSE,
    CAPITAL,
    KANA,
    HANGUAL,
    HANGUL,
    JUNJA,
    FINAL,
    HANJA,
    KANJI,
    ESCAPE,
    CONVERT,
    NONCONVERT,
    ACCEPT,
    MODECHANGE,
    SPACE,
    PRIOR,
    NEXT,
    END,
    HOME,
    LEFT,
    UP,
    RIGHT,
    DOWN,
    SELECT,
    PRINT,
    EXECUTE,
    SNAPSHOT,
    INSERT,
    DeLETE,
    HELP,
    ZERO,
    ONE,
    TWO,
    THREE,
    FOUR,
    FIVE,
    SIX,
    SEVEN,
    EIGHT,
    NINE,
    A,
    B,
    C,
    D,
    E,
    F,
    G,
    H,
    I,
    J,
    K,
    L,
    M,
    N,
    O,
    P,
    Q,
    R,
    S,
    T,
    U,
    V,
    W,
    X,
    Y,
    Z,
    LWIN,
    RWIN,
    APPS,
    SLEEP,
    NUMPAD0,
    NUMPAD1,
    NUMPAD2,
    NUMPAD3,
    NUMPAD4,
    NUMPAD5,
    NUMPAD6,
    NUMPAD7,
    NUMPAD8,
    NUMPAD9,
    MULTIPLY,
    ADD,
    SEPARATOR,
    SUBTRACT,
    DECIMAL,
    DIVIDE,
    F1,
    F2,
    F3,
    F4,
    F5,
    F6,
    F7,
    F8,
    F9,
    F10,
    F11,
    F12,
    F13,
    F14,
    F15,
    F16,
    F17,
    F18,
    F19,
    F20,
    F21,
    F22,
    F23,
    F24,
    NUMLOCK,
    SCROLL,
    LSHIFT,
    RSHIFT,
    LCONTROL,
    RCONTROL,
    LMENU,
    RMENU,
    BROWSER_BACK,
    BROWSER_FORWARD,
    BROWSER_REFRESH,
    BROWSER_STOP,
    BROWSER_SEARCH,
    BROWSER_FAVORITES,
    BROWSER_HOME,
    VOLUME_MUTE,
    VOLUME_DOWN,
    VOLUME_UP,
    MEDIA_NEXT_TRACK,
    MEDIA_PREV_TRACK,
    MEDIA_STOP,
    MEDIA_PLAY_PAUSE,
    LAUNCH_MAIL,
    LAUNCH_MEDIA_SELECT,
    LAUNCH_APP1,
    LAUNCH_APP2,
    OEM_1,
    OEM_2,
    OEM_3,
    OEM_4,
    OEM_5,
    OEM_6,
    OEM_7,
    OEM_8,
    OEM_PLUS,
    OEM_COMMA,
    OEM_MINUS,
    OEM_PERIOD,
    OEM_102,
    PROCESSKEY,
    PACKET,
    ATTN,
    CRSEL,
    EXSEL,
    EREOF,
    PLAY,
    ZOOM,
    NONAME,
    PA1,
    OEM_CLEAR
}

/**
 * @description
 * Describes a general mouse event.
 * Used when registering to listen on user actions.
 */
enum MouseAction {
    RBUTTON,
    LBUTTON,
    SCROLL,
    MOVE
}

/**
 * @description
 * Used to describe how window searches should filter non visible windows.
 */
enum VisibilityRule {
    VisibleOnly,
    HiddenAlso
}

/**
 * @description
 * Allows you to make GUI actions and listen to events of the GUI.
 * All GUI actions are using actual mouse and keyboard.
 */
declare module GUI {

    /**
     * @description
     * Used to describe window coordinates.
     * The x and y are normalized. Meaning that the x and y are
     * not using pixels but x of 1000 is always to the far right
     * and 500 is in the middle of the window.
     * This is to remove most concerns about window sizing.
     * 
     * The numbers are between 0 and 1000 and anything else
     * will cause an exception to be thrown.
     * And finally position (0, 0) is in the top left corner.
     * Which means higher y values means lower down on the window
     * and higher x values means more to the right.
     */
    class Coordinate {
        x: number;
        y: number;
    }

    /**
     * @description
     * Very much like GUI.MousePos but with a key.
     * Check GUI.MousePos for more information.
     */
    class MouseParam extends Coordinate {
        key: Mouse;
    }

    /**
     * @description
     * Describes a line from one position to another.
     */
    class MouseLine {
        from: Coordinate;
        to: Coordinate;
    }

    /**
     * @description
     * Describes a line from one position to another
     * with the addition of a key which will be activated
     * all the way from to to.
     */
    class MouseKeyLine extends MouseLine {
        key: Mouse;
    }

    /**
     * @description
     * Describes a command to send to a window
     * using Window.keyboardCommand.
     * Notice that when the key is a string only
     * one character is allowed and that character
     * has to be a number (0-9) or an english character (a-z or A-Z).
     * To send text, use Window.writeText.
     * The string is used when you want to send
     * commands which uses the normal text writing
     * buttons with a modifier like ctrl+T.
     */
    class KeyCommandParam {
        key: Keybutton | string;
        shift: boolean;
        ctrl: boolean;
        alt: boolean;
    }

    /**
     * @description
     * Represents an color using the basic colors
     * red, green and blue.
     */
    class Color {
        r: number
        g: number
        b: number
    }

    /**
     * @description
     * The parameter used to compare a single pixel against a color.
     * Check GUI.Coordinate for more information.
     */
    class PixelColorCmpParam extends Coordinate {
        color: Color;
    }

    /**
     * @description
     * The parameter is used to compare an whole rectangle of pixels
     * against an color.
     * The width and height properties uses the same metric as 
     * the Coordinate class uses.
     * An width + x or height + y which reaches outside the window
     * (number 1000) will cause an exception to be thrown on first
     * call.
     */
    class RectColorCmpParam extends Coordinate {
        width: number;
        height: number;
        color: Color;
    }

    /**
     * @description
     * Parameter used to describe a filter and a callback which will be used
     * to listen on user keyboard actions.
     * 
     * The from and to variables are inclusive and from can not be larger than
     * to. That will cause an error to be thrown.
     */
    class KeyboardEventFilter {
        from: VirtualKey;
        to: VirtualKey;
        callback: (ev: VirtualKey)=>void;
    }

    /**
     * @description
     * Parameter used to describe a filter and a callback which will be used
     * to listen on user mouse actions.
     * 
     * The from and to variables are inclusive and from can not be larger than
     * to. That will cause an error to be thrown.
     */
    class MouseEventFilter {
        event: MouseAction;
        callback: (x: number, y:number)=>void;
    }

    /**
     * @description
     * Represents a window from which you can interact with as a foreground window.
     * Using mouse clicks, keyboard clicks and events.
     * Automaticly handling events of getting focus of the window
     * you want to operate on and makes sure the clicks and mouse moves
     * look reasonably human.
     * 
     * @example
     * ```javascript
     * 
     * //Get window and make a click in the middle of the screen
     * var window = GUI.singleWindow("Heroes of the Storm");
     * window.mouseClick({
     *     x: 500,
     *     y: 500,
     *     key: Mouse.Lbutton
     * });
     * ```
     * 
     * @example
     * ```javascript
     * 
     * //Send ctrl+M
     * var window = GUI.singleWindow("Heroes of the Storm");
     * window.keyboardCommand({
     *     key: "m",
     *     ctrl: true
     * });
     * ```
     * 
     * @example
     * ```javascript
     * 
     * //Get the window and 
     * var window = GUI.singleWindow("Heroes of the Storm");
     * window.keyboardCommand({
     *     key: Keybutton.F4
     * });
     * ```
     */
    interface Window {

        /**
         * @description
         * The caption which is shown at the top left of the window.
         */
        readonly caption: string;

        /**
         * @description
         * Whether the window is visible as if it is in the foreground.
         * Meaning it could be visible even if it is hidden by other
         * windows or is minimized.
         */
        readonly visible: boolean;

        /**
         * @description
         * Clicks with a mouse button on selected part of the screen.
         * Mouse is moved to that location as a human would.
         * 
         * @throws If window does not exist anymore or parameters are invalid.
         */
        mouseClick(param: MouseParam): void;

        /**
         * @description
         * Moves the mouse to one location and drags the mouse with a button
         * held from location "from" to location "to".
         * 
         * @throws If window does not exist anymore or parameters are invalid.
         */
        mouseDrag(param: MouseKeyLine): void;

        /**
         * @description
         * Moves the mouse to one location and then moves the mouse again
         * from that location to the end location.
         */
        mouseMove(param: MouseLine): void;

        /**
         * @description
         * Send keyboard commands to the window.
         * You can send special characters or a single character with
         * shift/ctrl/alt modifiers. Do not use this to send text.
         * This is because characters are translated into upper case
         * to fit with the event passing protocol.
         * 
         * @throws If window does not exist any longer or param is invalid.
         */
        keyboardCommand(command: KeyCommandParam): void;

        /**
         * @description
         * Compares a pixel of this window against an RGB color.
         * 
         * @throws If coordinates are out of window bounds or if parameters are invalid.
         * @returns An percentual score of how equal the pixel are where 0 are not equal at all
         * and 100 they are identical.
         */
        colorPixelEquality(color: PixelColorCmpParam): number;

        /**
         * @description
         * Compares an whole rectangle of this window against an RGB color.
         * 
         * @throws If coordinates are out of window bounds or if parameters are invalid.
         * @returns An percentual score of how equal the pixels are where 0 are not equal at all
         * and 100 means that they are identical.
         */
        colorRectEquality(color: RectColorCmpParam): number;

        /**
         * @description
         * Listen to a range of user events.
         * 
         * @throws If parameters are invalid.
         * 
         * @example
         * ```javascript
         * 
         * //Print when F1 to F6 is clicked
         * var window = GUI.singleWindow("Heroes of the Storm");
         * window.listenToKeyboard({
         *     from: VirtualKey.F1,
         *     to: VirtualKey.F6,
         *     callback: function(vk) {
         *         var btn = "F" + (vk - 0x70 + 1);
         *         print(btn + " clicked");
         *     }
         * });
         * 
         * //Run forever. Whenever the user makes a left click of the
         * //Heroes of the Storm window this will print the position.
         * while(true) {
         *     var i = 0;  //This is due to a bug in the engine, otherwise bot is not stopable.
         * }
         * ```
         */
        listenToKeyboard(filter: KeyboardEventFilter): void;

        /**
         * @description
         * Listen to an type of mouse events.
         * 
         * @throws If parameters are invalid.
         * 
         * @example
         * ```javascript
         * 
         * //Log mouse position
         * var window = GUI.singleWindow("Heroes of the Storm");
         * //Throws if window could not be found
         * window.listenToMouse({
         *     event: MouseAction.LBUTTON,
         *     callback: function(x, y) {
         *         print("(", x, ",", y, ")");
         *     }
         * });
         * 
         * //Run forever. Whenever the user makes a left click of the
         * //Heroes of the Storm window this will print the position.
         * while(true) {
         *     var i = 0;  //This is due to a bug in the engine, otherwise bot is not stopable.
         * }
         * ```
         */
        listenToMouse(filter: MouseEventFilter): void;
    }

    /**
     * @description
     * Get all windows of the entire system including top windows and child windows.
     * By default all visible windows are
     * returned. You can change this by passing
     * VisibilityRule.HiddenAlso
     * 
     * @example
     * ```javascript
     * 
     * //Count all visible windows
     * var all_windows = GUI.allWindows();
     * print(all_windows.length);
     * ```
     * 
     * @example
     * ```javascript
     * 
     * //Count all windows including those not visible
     * var all_windows = GUI.allWindows(VisibilityRule.HiddenAlso);
     * print(all_windows.length);
     * ```
     */
    function allWindows(rule?: VisibilityRule): Window[];

    /**
     * @description
     * Gives all windows with a certain caption. Both child windows and top windows.
     * By default only visible windows are returned.
     * This can be changed by passing VisibilityRule.HiddenAlso
     * 
     * @example
     * ```javascript
     * 
     * //Get window and prove it has the same caption
     * var windows = GUI.windows("Heroes of the Storm");
     * print(windows.length);
     * // -> Probably prints 1 or 0 because Heroes of the storm can only run one instance at a time
     * ```
     */
    function windows(caption: string, rule?: VisibilityRule): Window[];

    /**
     * @description
     * Gets a single window with a certain caption.
     * By default only visible windows are returned.
     * This can be changed by passing VisibilityRule.HiddenAlso.
     * 
     * @throws If there are no window or there are more than one window with that caption.
     * 
     * @example
     * ```javascript
     * 
     * //Get window and make sure it exists
     * var window = GUI.singleWindow("Heroes of the Storm");
     * //Throws if window does not exist
     * print(window.caption);
     * ```
     */
    function singleWindow(caption: string, rule: VisibilityRule): Window;
}



//Processes

/**
 * @description
 * With the processes you can be very basic operations spanning from querying the processes
 * and starting and killing them to doing really advanced process introspection by 
 * reading memory pointers, scanning memory, injecting code, hooking, listening for message
 * events, getting the process main window etc etc...
 */
declare module Processes {

    type Arch = "x86" | "x64" | "eitherArch";

    /**
     * @description
     * Describes a native value in conjunction with a script value.
     * This is used in the memory reading and writing calls to
     * be able to specify exactly what to write to memory.
     * 
     * @important
     * When using NativeType in conjunction with a value make sure
     * that the native type is an scalar type if value is a number.
     * "string" if value is a string or array if value is an array.
     * 
     * @someflow
     * If underflow or overflow happens when the value is an number | number[]
     * then a warning is produced and the value is converted to the maximum
     * or minimum value. Choosing which one is more appropriate.
     */
    type NativeType =
        "int8"
        | "int16"
        | "int32"
        | "int64"
        | "double"
        | "float"
        | "uint8"
        | "uint16"
        | "uint32"
        | "uint64"
        | "string"

        | "int8[]"
        | "int16[]"
        | "int32[]"
        | "int64[]"
        | "double[]"
        | "float[]"
        | "uint8[]"
        | "uint16[]"
        | "uint32[]"
        | "uint64[]";


    /**
     * @description
     * Used in calls to Process.find* functions. Specifies a pattern to search for.
     */
    class MemoryFilter {

        /**
         * @description
         * The type of the value
         */
        type: NativeType;

        /**
         * @description
         * The value type. The type of this depends on the type. Check the type docs for more info.
         */
        value: number | string | number[];
    }

    /**
     * @description
     * Represents an address from which many of the Process
     * operations are performed with the address as base. 
     */
    interface Address {

        /**
         * @description
         * The actual memory address which this Address object represents. 
         */
        readonly address: number;

        /**
         * @description
         * Reads at this memory location.
         * Reading strings is special. If no length are specified the string is considered "boxed" which means it ends and starts with 0.
         * Generally this is true for single byte strings which is the most common in games.
         * If the string is not boxed specify the length and make sure the address is at base and you are good.
         * 
         * @param length Only used if type is an array type. (A type which name ends with [])
         * @throws If address is out of bounds or if address is not readable
         */
        read(type: NativeType, length?: number): string | number | number[];

        /**
         * @description
         * Writes at this memory location.
         * Check Process.write for more information
         * 
         * @throws If type and value does not match or the address could not be written to.
         */
        write(type: NativeType, value: string): void;

        /**
         * @description
         * Reads a pointer chain with this address as the base.
         * Check Process.readPointers for more information.
         */
        readPointers(offsets: number[]): Address;

        /**
         * @description
         * Searches for first occurency of patterns.
         * Check Process.findFirst for more information.
         */
        findFirst(patterns: MemoryFilter[]): Address | null;
        findFirst(length: number, patterns: MemoryFilter[]): Address | null;

        /**
         * @description
         * Searches for all occurencies of a pattern.
         * Check Process.findAll for more information.
         */
        findAll(patterns: MemoryFilter[]): Address[];
        findAll(length: number, patterns: MemoryFilter[]): Address[];
    }

    /**
     * @description
     * Represents an Memory Module (.dll / .exe) and allows you to several types of manipulation to it.
     */
    interface Module {

        /**
         * @description
         * The address of this module.
         */
        readonly address: number;

        /**
         * @description
         * Reads at an offset. Check out Process.read for more information.
         * 
         * @throws If the process is not running or the memory region is not readable.
         */
        readOffset(type: NativeType, offset: number): string | number | number[];

        /**
         * @description
         * Write at an offset within the module. Check out Process.write for more information.
         * 
         * @throws If the process is not running or the memory region is not writable.
         */
        writeOffset(type: NativeType, value: string | number | number[], offset: number): void;
    }

    /**
     * @description
     * The swiss army knife for everything you may want to do with a process.
     * Goes from anything memory relatived, code execution to mouse actions
     * and listening to mouse and keyboard events.
     */
    interface Process {

        /**
         * @description
         * Unconditionally kills the process.
         * 
         * @throws If process could not be killed
         * 
         * @example
         * ```javascript
         * 
         * //Make sure a process can not be started
         * for (;;) {
         *     var notepads = Processes.pidsByName("notepad++.exe", "eitherArch");
         *     for (i = 0; i < notepads.length; i++) {
         *         var p = Processes.open(notepads[i]);
         *         p.kill();
         *     }
         * }
         * //Above calls does throw if process does not exist
         * ```
         */
        kill(): void;

        /**
         * @description
         * Starts a new process which will be killed once the reference to this
         * object is destroyed.
         * 
         * @throws If process could not start or parameters are invalid
         * 
         * @example
         * ```javascript
         * 
         * //Start notepad and kill it automaticly when ending bot
         * var notepad_exe = FileSystem.root.file("C://Program Files (x86)/Notepad++/notepad++.exe");
         * //Throws if file does not exist
         * 
         * var process = Processes.start(notepad_exe.pathOf);
         * //Process will now start, and will instantly be killed because the bot ends
         * ```
         */



        /**
         * @description
         * Read from an arbitrary address in memory.
         * Reading strings is special. If no length are specified the string is considered "boxed" which means it ends and starts with 0.
         * Generally this is true for single byte strings which is the most common in games.
         * If the string is not boxed specify the length and make sure the address is at base and you are good.
         * 
         * @param length Only used if type is an array type. (A type which name ends with [])
         * @throws If address is out of bounds or if address is not readable
         * 
         * 
         * @example
         * ```javascript
         * 
         * //Read from an arbitrary position in memory
         * //Useful when processes have static data
         * var process = Processes.open(Processes.selectedPid);
         * var value = process.read("int32", 0xA240000);
         * print("Read value ", value);
         * //Throws if address could not read from
         * ```
         * 
         * @example
         * ```javascript
         * 
         * //Read array from an arbitrary address
         * var process = Processes.open(Processes.selectedPid);
         * var array = process.read("int32[]", 0xA240000, 2);
         * for(i = 0; i < array.length; i++)
         *     print(array[i]);
         * ```
         * 
         * @example
         * ```javascript
         * 
         * //Read string from an arbitrary address
         * //When not specifying length The "boxing" technique is used
         * var process = Processes.open(Processes.selectedPid);
         * var str = process.read("string", 0x211135F);
         * print(str);
         * ```
         * 
         * @example
         * ```javascript
         * 
         * //Read string with a specified length
         * //The address then has to point to the base of the string
         * var process = Processes.open(Processes.selectedPid);
         * var str = process.read("string", 0x01FB135F, 4);    //4 is the length of the string
         * print(str);
         * ```
         */
        read(type: NativeType, address: number, length?: number): number | string | number[];


        /**
         * @description
         * Write to an arbitrary address in memory.
         * 
         * @throws If type and value does not match or the address could not be written to.
         * 
         * @example
         * ```javascript
         * 
         * //Write to some addresses
         * var process = Processes.open(Processes.selectedPid);
         * var address = 0x22880000;
         * process.write("int32", 42, address);
         * process.write("int32[]", [100, 10], address);
         * process.write("string", "zebra", address);
         * //The above calls could throw if the values are out of range or type and actual type does not match
         * ```
         */
        write(type: NativeType, address: number, value: string | number | number[]): void;

        /**
         * @description
         * Reads a pointerchain.
         * Returns the address to which the pointer chain points to.
         * This allows you to get the value of the address immedietly after a call to this.
         * 
         * @throws If pointers could not be read or parameters and invalid.
         * 
         * @example
         * ```javascript
         * 
         * //Read from a pointer chain. Where the final offset is the desired value
         * var process = Processes.open(Processes.selectedPid);
         * var module = "HeroesOfTheStorm.exe";
         * var offsets = [
         *     0x52723,    //Base offset
         *     0x20,
         *    0x30
         * ];
         * 
         * var address = process.readPointers(module, offsets);
         * //Throws if pointer could not be read
         * 
         * var value = address.read("int32");
         * print("Pointer chain points to value ", value);
         * ```
         */
        readPointers(module: string, offsets: number[]): Address;

        /**
         * @description
         * Gives you a reference to a memory module. From which you can manipulate it.
         * 
         * @throws If module could not be found or parameter is invalid.
         * 
         * @example
         * ```javascript
         * 
         * //Get a module and print it's address
         * var process = Processes.open(Processes.selectedPid);
         * var module = process.module("kernel32.dll");
         * //Throws if module could not found
         * print(module.address);
         * ```
         */
        module(name: string): Module;

        /**
         * @description
         * Injects a module inside of the target process.
         * Which you can fiddle with as a module.
         * 
         * @param rel_path The relative path of the module relative from plugin path.
         * @throws If module path could not be found.
         * 
         * @example
         * ```javascript
         * 
         * //Inject a DLL with path relative to botrunner dir
         * var process = Processes.open(Processes.selectedPid);
         * var module = process.injectModule("msdia80.dll");
         * //Throws if module does not exist at botrunner path
         * print(module.address);
         * ```
         */
        injectModule(rel_path: string): Module;

        /**
         * @description
         * Finds the first of a number of patterns
         * in range of memory, or whole.
         * 
         * To search whole readable memory 
         * pass in only the patterns.
         * 
         * If you want to search within a memory
         * range pass the base and length and then
         * the patterns. 
         * 
         * @throws If any pattern is invalid
         * 
         * @example
         * ```javascript
         * 
         * //Find all occurencies of the text PLAY
         * var process = Processes.open(Processes.selectedPid);
         * var occurency = process.findFirst([
         *     {
         *         type: "string",
         *         value: "PLAY"
         *     }
         * ]);
         * if(!occurency) {
         *     print("Could not find text PLAY");
         * } else {
         *     print(occurency.address);
         * }
         * ```
         * 
         * @example
         * ```javascript
         * 
         * var process = Processes.open(Processes.selectedPid);
         * var occurency = process.findFirst([
         *     {
         *         type: "int32[]",
         *         value: [42, 42, 42, 42]
         *     }
         * ]);
         * if(!occurency) {
         *     print("Could not find array");
         * } else {
         *     print(occurency.address);
         * }
         * ```
         * 
         * @example
         * ```javascript
         * 
         * var process = Processes.open(Processes.selectedPid);
         * var occurency = process.findFirst([
         *     {
         *         type: "int32",
         *         value: 42
         *     }
         * ]);
         * 
         * if(!occurency) {
         *     print("Could not find array");
         * } else {
         *     print(occurency.address);
         * }
         * ```
         */
        findFirst(patterns: MemoryFilter[]): Address | null;
        findFirst(from: number, length: number, patterns: MemoryFilter[]): Address | null;


        /**
         * @description
         * Finds all matches of a number of patterns
         * in range of memory, or whole.
         * 
         * To search whole readable memory 
         * pass in only the patterns.
         * 
         * If you want to search within a memory
         * range pass the base and length and then
         * the patterns. 
         * 
         * @throws If any pattern is invalid
         * 
         * @example
         * ```javascript
         * 
         * var process = Processes.open(Processes.selectedPid);
         * var occurencies = process.findAll([
         *     {
         *         type: "string",
         *         value: "PLAY"
         *     }
         * ]);
         * if(!occurencies.length) {
         *     print("Could not find any string");
         * } else {
         *     print(occurencies.length);
         * }
         * ```
         * 
         * @example
         * ```javascript
         * 
         * var process = Processes.open(Processes.selectedPid);
         * var occurencies = process.findAll([
         *     {
         *         type: "int32[]",
         *         value: [42, 42, 42]
         *     }
         * ]);
         * if(!occurencies.length) {
         *     print("Could not find any array");
         * } else {
         *     print(occurencies.length);
         * }
         * ```
         */
        findAll(patterns: MemoryFilter[]): Address[];
        findAll(from: number, length: number, patterns: MemoryFilter[]): Address[];

        /**
         * @description
         * Gives you the main window of the process.
         * If there are more than one window visible at
         * one time call the windowWithCaption function instead.
         * In that case this method will throw.
         * 
         * @throws If main window could not be figured out.
         * 
         * @example
         * ```javascript
         * 
         * var process = Processes.open(Processes.selectedPid);
         * //Selected pid is a botrunner setting which is available for process botrunners
         * var main_window = process.mainWindow();  //Throws if main window could not be found
         * print(main_window.caption);
         * ```
         */
        mainWindow(): GUI.Window;

        /**
         * @description
         * Gives you the window with the specified caption.
         * 
         * @throws If a window with that caption could not be found.
         * 
         * @example
         * ```javascript
         * 
         * var process = Processes.open(Processes.selectedPid);
         * var window = process.windowWithCaption("Heroes of the Storm");
         * print(window.visible);
         * ```
         */
        windowWithCaption(caption: string): GUI.Window;

        /**
         * @description
         * Gets all windows of the process. 
         * Including both toplevel and child windows.
         * 
         * @throws If process is no longer running
         * 
         * @example
         * ```javascript
         * 
         * //Print the windows of current process
         * var process = Processes.open(Processes.selectedPid);
         * var windows = process.allWindows();
         * print(windows.length);
         * //Usually prints more than one even for single windowed applications.
         * //Because the have invisible windows.
         * ```
         */
        allWindows(): GUI.Window[];

        /**
         * @description
         * Gives you the directory of the process.
         * 
         * @throws If process is no longer running
         */
        dir(): FileSystem.Dir;

    }

    /**
     * @description
     * The the alive processes you are interested in and their pids.
     * With this you can then open it using the open function.
     * @throws If Arch is not a valid type
     * 
     * @example
     * ```javascript
     * 
     * //Get main window and make a click
     * var notepads = Processes.pidsByName("notepad++.exe", "x86");
     * //Above throws if processes could not be found
     * for(i = 0; i < notepads.length; i++)
     *    Log.normal(notepads[i]);
     * //Logs all the processes pids with name notepad and is of architecture x86
     * ```
     */
    function pidsByName(name: string, arch: Arch);


    /**
     * @description
     * Opens up a process from which a whole world of introspection opens up.
     * 
     * @example
     * ```javascript
     * 
     * var process = Processes.open(Processes.selectedPid);
     * //Selected pid is a botrunner setting which is available for process botrunners
     * var main_window = process.mainWindow();  //Throws if main window could not be found
     * main_window.mouseClick(500, 500);    //Mouseclick in the middle of the window
     *                                      //Waits for the window to become active if it does not have focus
     * ```
     */
    function open(pid: number): Process;

    /**
     * @description
     * If the botrunner if of type "process" then this is set to the selected key from
     * which the user started the bot on.
     * 
     * @example
     * BotRunner file:
     * ```json
     * 
     * {
     *  "name": "foo",
     *  "type": "process",
     *  "process_name": "notepad++.exe",
     *  "arch": "x86",
     *  "executable": "bot.js"
     * }
     * 
     * ```
     * This will cause BotKitty to look for notepad++.exe which runs as x86.
     * 
     * ```javascript
     * 
     * var pid = Processes.selectedPid;
     * //pid now contains the pid which the user started the bot with.
     * ```
     */
    const selectedPid: number;
}
